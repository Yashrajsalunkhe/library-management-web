-- ===============================================================
-- OPTIMIZED LIBRARY MANAGEMENT SYSTEM SCHEMA
-- ===============================================================
-- This schema prevents cascading deletions and improves performance
-- with proper indexes and constraints

-- Enable required extensions
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- =================================================================
-- 1. AUTHENTICATION & USER MANAGEMENT
-- =================================================================

-- Profiles table (linked to Supabase Auth)
CREATE TABLE IF NOT EXISTS public.profiles (
  id UUID REFERENCES auth.users ON DELETE CASCADE NOT NULL PRIMARY KEY,
  username TEXT UNIQUE,
  full_name TEXT,
  email TEXT,
  role TEXT DEFAULT 'admin' CHECK (role IN ('admin', 'receptionist', 'librarian', 'staff')),
  avatar_url TEXT,
  is_active BOOLEAN DEFAULT true,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Index for faster lookups
CREATE INDEX IF NOT EXISTS idx_profiles_username ON public.profiles(username);
CREATE INDEX IF NOT EXISTS idx_profiles_email ON public.profiles(email);
CREATE INDEX IF NOT EXISTS idx_profiles_role ON public.profiles(role) WHERE is_active = true;

-- =================================================================
-- 2. MEMBERSHIP PLANS
-- =================================================================

CREATE TABLE IF NOT EXISTS public.membership_plans (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name TEXT NOT NULL,
  duration_days INTEGER NOT NULL CHECK (duration_days >= 0),
  price DECIMAL(10,2) NOT NULL CHECK (price >= 0),
  description TEXT,
  is_active BOOLEAN DEFAULT true,
  seat_access BOOLEAN DEFAULT true,
  book_limit INTEGER DEFAULT 0 CHECK (book_limit >= 0),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Index for active plans
CREATE INDEX IF NOT EXISTS idx_membership_plans_active ON public.membership_plans(is_active);

-- =================================================================
-- 3. MEMBERS TABLE
-- =================================================================

CREATE TABLE IF NOT EXISTS public.members (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name TEXT NOT NULL,
  email TEXT,
  phone TEXT,
  birth_date DATE,
  city TEXT,
  address TEXT,
  seat_no TEXT UNIQUE,
  library_card_no TEXT UNIQUE,
  id_document_type TEXT,
  id_number TEXT,
  photo_url TEXT,
  
  -- Plan relationship with RESTRICT to prevent accidental plan deletion
  plan_id BIGINT REFERENCES public.membership_plans(id) ON DELETE RESTRICT,
  
  join_date DATE DEFAULT CURRENT_DATE,
  end_date DATE,
  status TEXT DEFAULT 'active' CHECK (status IN ('active', 'expired', 'suspended', 'inactive')),
  
  -- Biometric data
  qr_code TEXT,
  fingerprint_template BYTEA,
  
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  
  -- Constraint to ensure end_date is after join_date
  CONSTRAINT valid_membership_dates CHECK (end_date IS NULL OR end_date >= join_date)
);

-- Indexes for faster searches and joins
CREATE INDEX IF NOT EXISTS idx_members_name ON public.members(name);
CREATE INDEX IF NOT EXISTS idx_members_email ON public.members(email);
CREATE INDEX IF NOT EXISTS idx_members_phone ON public.members(phone);
CREATE INDEX IF NOT EXISTS idx_members_library_card_no ON public.members(library_card_no);
CREATE INDEX IF NOT EXISTS idx_members_seat_no ON public.members(seat_no) WHERE seat_no IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_members_status ON public.members(status);
CREATE INDEX IF NOT EXISTS idx_members_plan_id ON public.members(plan_id);
CREATE INDEX IF NOT EXISTS idx_members_end_date ON public.members(end_date) WHERE status = 'active';

-- =================================================================
-- 4. PAYMENTS TABLE (CRITICAL FIX)
-- =================================================================
-- Using ON DELETE SET NULL to preserve payment history when member is deleted

CREATE TABLE IF NOT EXISTS public.payments (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  
  -- SET NULL on delete to preserve payment records for accounting
  member_id BIGINT REFERENCES public.members(id) ON DELETE SET NULL,
  
  amount DECIMAL(10,2) NOT NULL CHECK (amount >= 0),
  payment_date TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL,
  payment_method TEXT DEFAULT 'cash' CHECK (payment_method IN ('cash', 'upi', 'card', 'bank_transfer', 'cheque', 'other')),
  transaction_id TEXT,
  
  -- Reference to plan (optional, for tracking which plan was paid for)
  plan_id BIGINT REFERENCES public.membership_plans(id) ON DELETE SET NULL,
  
  type TEXT DEFAULT 'membership' CHECK (type IN ('membership', 'fine', 'deposit', 'renewal', 'other')),
  receipt_number TEXT UNIQUE,
  notes TEXT,
  
  -- Track who recorded the payment
  created_by UUID REFERENCES public.profiles(id) ON DELETE SET NULL,
  
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes for faster queries and reporting
CREATE INDEX IF NOT EXISTS idx_payments_member_id ON public.payments(member_id);
CREATE INDEX IF NOT EXISTS idx_payments_payment_date ON public.payments(payment_date DESC);
CREATE INDEX IF NOT EXISTS idx_payments_payment_method ON public.payments(payment_method);
CREATE INDEX IF NOT EXISTS idx_payments_type ON public.payments(type);
CREATE INDEX IF NOT EXISTS idx_payments_created_by ON public.payments(created_by);
CREATE INDEX IF NOT EXISTS idx_payments_receipt_number ON public.payments(receipt_number);

-- Composite index for common queries (member payments by date)
CREATE INDEX IF NOT EXISTS idx_payments_member_date ON public.payments(member_id, payment_date DESC) WHERE member_id IS NOT NULL;

-- =================================================================
-- 5. ATTENDANCE TABLE
-- =================================================================
-- DELETE CASCADE is appropriate here since attendance records
-- belong to members and have no standalone value

CREATE TABLE IF NOT EXISTS public.attendance (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  
  -- CASCADE on delete - attendance records are dependent on members
  member_id BIGINT NOT NULL REFERENCES public.members(id) ON DELETE CASCADE,
  
  check_in TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL,
  check_out TIMESTAMP WITH TIME ZONE,
  source TEXT DEFAULT 'manual' CHECK (source IN ('biometric', 'manual', 'card', 'qr')),
  
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  
  -- Constraint to ensure check_out is after check_in
  CONSTRAINT valid_attendance_times CHECK (check_out IS NULL OR check_out >= check_in)
);

-- Indexes for attendance queries
CREATE INDEX IF NOT EXISTS idx_attendance_member_id ON public.attendance(member_id);
CREATE INDEX IF NOT EXISTS idx_attendance_check_in ON public.attendance(check_in DESC);
CREATE INDEX IF NOT EXISTS idx_attendance_source ON public.attendance(source);

-- Composite index for member attendance history
CREATE INDEX IF NOT EXISTS idx_attendance_member_date ON public.attendance(member_id, check_in DESC);

-- =================================================================
-- 6. EXPENDITURES TABLE
-- =================================================================

CREATE TABLE IF NOT EXISTS public.expenditures (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  title TEXT NOT NULL,
  description TEXT,
  category TEXT NOT NULL CHECK (category IN ('books', 'electricity', 'rent', 'salaries', 'maintenance', 'stationery', 'internet', 'other')),
  amount DECIMAL(10,2) NOT NULL CHECK (amount >= 0),
  payment_mode TEXT DEFAULT 'cash' CHECK (payment_mode IN ('cash', 'card', 'upi', 'bank_transfer', 'cheque')),
  date DATE NOT NULL DEFAULT CURRENT_DATE,
  receipt_number TEXT,
  notes TEXT,
  
  -- Track who recorded the expenditure
  created_by UUID REFERENCES public.profiles(id) ON DELETE SET NULL,
  
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes for expenditure reporting
CREATE INDEX IF NOT EXISTS idx_expenditures_date ON public.expenditures(date DESC);
CREATE INDEX IF NOT EXISTS idx_expenditures_category ON public.expenditures(category);
CREATE INDEX IF NOT EXISTS idx_expenditures_created_by ON public.expenditures(created_by);

-- =================================================================
-- 7. BOOKS & BOOK ISSUES (OPTIONAL)
-- =================================================================

CREATE TABLE IF NOT EXISTS public.books (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  title TEXT NOT NULL,
  author TEXT,
  isbn TEXT UNIQUE,
  category TEXT,
  total_copies INTEGER DEFAULT 1 CHECK (total_copies >= 0),
  available_copies INTEGER DEFAULT 1 CHECK (available_copies >= 0),
  shelf_location TEXT,
  
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  
  -- Constraint to ensure available_copies never exceeds total_copies
  CONSTRAINT valid_copy_count CHECK (available_copies <= total_copies)
);

-- Indexes for book searches
CREATE INDEX IF NOT EXISTS idx_books_title ON public.books(title);
CREATE INDEX IF NOT EXISTS idx_books_author ON public.books(author);
CREATE INDEX IF NOT EXISTS idx_books_isbn ON public.books(isbn);
CREATE INDEX IF NOT EXISTS idx_books_category ON public.books(category);

CREATE TABLE IF NOT EXISTS public.book_issues (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  
  -- RESTRICT on delete to prevent deletion of books that have issue history
  book_id BIGINT REFERENCES public.books(id) ON DELETE RESTRICT,
  
  -- SET NULL to preserve issue history when member is deleted
  member_id BIGINT REFERENCES public.members(id) ON DELETE SET NULL,
  
  issue_date DATE DEFAULT CURRENT_DATE NOT NULL,
  due_date DATE NOT NULL,
  return_date DATE,
  status TEXT DEFAULT 'issued' CHECK (status IN ('issued', 'returned', 'overdue', 'lost')),
  fine_amount DECIMAL(10,2) DEFAULT 0 CHECK (fine_amount >= 0),
  
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  
  -- Constraint to ensure valid dates
  CONSTRAINT valid_issue_dates CHECK (
    due_date >= issue_date AND 
    (return_date IS NULL OR return_date >= issue_date)
  )
);

-- Indexes for book issue queries
CREATE INDEX IF NOT EXISTS idx_book_issues_book_id ON public.book_issues(book_id);
CREATE INDEX IF NOT EXISTS idx_book_issues_member_id ON public.book_issues(member_id);
CREATE INDEX IF NOT EXISTS idx_book_issues_status ON public.book_issues(status);
CREATE INDEX IF NOT EXISTS idx_book_issues_issue_date ON public.book_issues(issue_date DESC);

-- =================================================================
-- 8. NOTIFICATIONS TABLE
-- =================================================================

CREATE TABLE IF NOT EXISTS public.notifications (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  
  -- CASCADE on delete - notifications are dependent on members
  member_id BIGINT NOT NULL REFERENCES public.members(id) ON DELETE CASCADE,
  
  type TEXT NOT NULL CHECK (type IN ('email', 'whatsapp', 'sms')),
  subject TEXT,
  message TEXT NOT NULL,
  status TEXT DEFAULT 'pending' CHECK (status IN ('pending', 'sent', 'failed')),
  sent_at TIMESTAMP WITH TIME ZONE,
  error_message TEXT,
  
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes for notification queries
CREATE INDEX IF NOT EXISTS idx_notifications_member_id ON public.notifications(member_id);
CREATE INDEX IF NOT EXISTS idx_notifications_status ON public.notifications(status);
CREATE INDEX IF NOT EXISTS idx_notifications_created_at ON public.notifications(created_at DESC);

-- =================================================================
-- 9. SETTINGS TABLE
-- =================================================================

CREATE TABLE IF NOT EXISTS public.settings (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  key TEXT UNIQUE NOT NULL,
  value JSONB,
  description TEXT,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Index for faster settings lookup
CREATE UNIQUE INDEX IF NOT EXISTS idx_settings_key ON public.settings(key);

-- =================================================================
-- 10. FUNCTIONS & TRIGGERS
-- =================================================================

-- Update timestamp trigger function
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Apply update triggers to tables
DROP TRIGGER IF EXISTS update_profiles_updated_at ON public.profiles;
CREATE TRIGGER update_profiles_updated_at BEFORE UPDATE ON public.profiles
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

DROP TRIGGER IF EXISTS update_members_updated_at ON public.members;
CREATE TRIGGER update_members_updated_at BEFORE UPDATE ON public.members
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

DROP TRIGGER IF EXISTS update_payments_updated_at ON public.payments;
CREATE TRIGGER update_payments_updated_at BEFORE UPDATE ON public.payments
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

DROP TRIGGER IF EXISTS update_membership_plans_updated_at ON public.membership_plans;
CREATE TRIGGER update_membership_plans_updated_at BEFORE UPDATE ON public.membership_plans
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

DROP TRIGGER IF EXISTS update_expenditures_updated_at ON public.expenditures;
CREATE TRIGGER update_expenditures_updated_at BEFORE UPDATE ON public.expenditures
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

DROP TRIGGER IF EXISTS update_books_updated_at ON public.books;
CREATE TRIGGER update_books_updated_at BEFORE UPDATE ON public.books
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Handle new user signup
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, username, full_name, email, role, avatar_url)
  VALUES (
    NEW.id,
    COALESCE(NEW.raw_user_meta_data->>'username', split_part(NEW.email, '@', 1)),
    NEW.raw_user_meta_data->>'full_name',
    NEW.email,
    COALESCE(NEW.raw_user_meta_data->>'role', 'admin'),
    NEW.raw_user_meta_data->>'avatar_url'
  );
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- Function to update book availability when issued/returned
CREATE OR REPLACE FUNCTION update_book_availability()
RETURNS TRIGGER AS $$
BEGIN
  IF (TG_OP = 'INSERT' AND NEW.status = 'issued') THEN
    UPDATE public.books 
    SET available_copies = available_copies - 1 
    WHERE id = NEW.book_id AND available_copies > 0;
  ELSIF (TG_OP = 'UPDATE' AND OLD.status = 'issued' AND NEW.status = 'returned') THEN
    UPDATE public.books 
    SET available_copies = available_copies + 1 
    WHERE id = NEW.book_id;
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS book_availability_trigger ON public.book_issues;
CREATE TRIGGER book_availability_trigger
  AFTER INSERT OR UPDATE ON public.book_issues
  FOR EACH ROW EXECUTE FUNCTION update_book_availability();

-- =================================================================
-- 11. ROW LEVEL SECURITY (RLS) POLICIES
-- =================================================================

-- Enable RLS on all tables
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.membership_plans ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.members ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.payments ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.attendance ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.expenditures ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.settings ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.books ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.book_issues ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.notifications ENABLE ROW LEVEL SECURITY;

-- Profiles policies
DROP POLICY IF EXISTS "Public profiles are viewable by everyone" ON public.profiles;
CREATE POLICY "Public profiles are viewable by everyone" 
  ON public.profiles FOR SELECT 
  USING (true);

DROP POLICY IF EXISTS "Users can insert their own profile" ON public.profiles;
CREATE POLICY "Users can insert their own profile" 
  ON public.profiles FOR INSERT 
  WITH CHECK (auth.uid() = id);

DROP POLICY IF EXISTS "Users can update own profile" ON public.profiles;
CREATE POLICY "Users can update own profile" 
  ON public.profiles FOR UPDATE 
  USING (auth.uid() = id);

-- Allow authenticated users full access to other tables
DROP POLICY IF EXISTS "Enable all for authenticated users" ON public.members;
CREATE POLICY "Enable all for authenticated users" 
  ON public.members FOR ALL 
  USING (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Enable all for authenticated users" ON public.membership_plans;
CREATE POLICY "Enable all for authenticated users" 
  ON public.membership_plans FOR ALL 
  USING (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Enable all for authenticated users" ON public.payments;
CREATE POLICY "Enable all for authenticated users" 
  ON public.payments FOR ALL 
  USING (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Enable all for authenticated users" ON public.attendance;
CREATE POLICY "Enable all for authenticated users" 
  ON public.attendance FOR ALL 
  USING (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Enable all for authenticated users" ON public.expenditures;
CREATE POLICY "Enable all for authenticated users" 
  ON public.expenditures FOR ALL 
  USING (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Enable all for authenticated users" ON public.settings;
CREATE POLICY "Enable all for authenticated users" 
  ON public.settings FOR ALL 
  USING (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Enable all for authenticated users" ON public.books;
CREATE POLICY "Enable all for authenticated users" 
  ON public.books FOR ALL 
  USING (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Enable all for authenticated users" ON public.book_issues;
CREATE POLICY "Enable all for authenticated users" 
  ON public.book_issues FOR ALL 
  USING (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Enable all for authenticated users" ON public.notifications;
CREATE POLICY "Enable all for authenticated users" 
  ON public.notifications FOR ALL 
  USING (auth.role() = 'authenticated');

-- =================================================================
-- 12. SAMPLE DATA (OPTIONAL)
-- =================================================================

-- Insert sample membership plans
INSERT INTO public.membership_plans (name, duration_days, price, description, seat_access, book_limit) VALUES
  ('Daily Reading', 1, 20.00, 'Daily reading room access only', true, 0),
  ('Monthly Reading', 30, 500.00, 'Monthly reading room access', true, 0),
  ('Student Monthly', 30, 300.00, 'Student discount - Monthly reading room', true, 0),
  ('Quarterly Reading', 90, 1200.00, 'Quarterly reading room access', true, 0),
  ('Annual Reading', 365, 5000.00, 'Annual reading room access', true, 0),
  ('Book Borrower Monthly', 30, 800.00, 'Monthly reading room + 3 books borrowing', true, 3),
  ('Premium Annual', 365, 8000.00, 'Annual reading room + 5 books borrowing', true, 5)
ON CONFLICT DO NOTHING;

-- Insert default settings
INSERT INTO public.settings (key, value, description) VALUES
  ('library_name', '"My Library"', 'Name of the library'),
  ('late_fee_per_day', '10', 'Fine amount per day for overdue books'),
  ('max_issue_days', '14', 'Maximum days a book can be issued'),
  ('auto_renewal_enabled', 'true', 'Enable automatic membership renewal'),
  ('notification_enabled', 'true', 'Enable notification system')
ON CONFLICT (key) DO NOTHING;
